// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENV_YASE_DEF_H_
#define FLATBUFFERS_GENERATED_ENV_YASE_DEF_H_

#include "flatbuffers/flatbuffers.h"

#include "base_generated.h"

namespace YASE {
namespace def {

struct ShaderProgram;

struct SkyBox;

struct Texture;

struct TextureSettings;

struct Ground;

struct Environment;

enum Wrapping {
  Wrapping_Repeat = 0,
  Wrapping_MirroredRepeat = 1,
  Wrapping_ClampEdge = 2,
  Wrapping_ClampBorder = 3,
  Wrapping_MIN = Wrapping_Repeat,
  Wrapping_MAX = Wrapping_ClampBorder
};

inline const Wrapping (&EnumValuesWrapping())[4] {
  static const Wrapping values[] = {
    Wrapping_Repeat,
    Wrapping_MirroredRepeat,
    Wrapping_ClampEdge,
    Wrapping_ClampBorder
  };
  return values;
}

inline const char * const *EnumNamesWrapping() {
  static const char * const names[] = {
    "Repeat",
    "MirroredRepeat",
    "ClampEdge",
    "ClampBorder",
    nullptr
  };
  return names;
}

inline const char *EnumNameWrapping(Wrapping e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWrapping()[index];
}

enum Filter {
  Filter_Nearest = 0,
  Filter_Linear = 1,
  Filter_MIN = Filter_Nearest,
  Filter_MAX = Filter_Linear
};

inline const Filter (&EnumValuesFilter())[2] {
  static const Filter values[] = {
    Filter_Nearest,
    Filter_Linear
  };
  return values;
}

inline const char * const *EnumNamesFilter() {
  static const char * const names[] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilter(Filter e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFilter()[index];
}

struct ShaderProgram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_VERTEX = 8,
    VT_FRAGMENT = 10,
    VT_GEOMETRY = 12,
    VT_TESSELATION = 14
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *vertex() const {
    return GetPointer<const flatbuffers::String *>(VT_VERTEX);
  }
  const flatbuffers::String *fragment() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAGMENT);
  }
  const flatbuffers::String *geometry() const {
    return GetPointer<const flatbuffers::String *>(VT_GEOMETRY);
  }
  const flatbuffers::String *tesselation() const {
    return GetPointer<const flatbuffers::String *>(VT_TESSELATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERTEX) &&
           verifier.VerifyString(vertex()) &&
           VerifyOffset(verifier, VT_FRAGMENT) &&
           verifier.VerifyString(fragment()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyString(geometry()) &&
           VerifyOffset(verifier, VT_TESSELATION) &&
           verifier.VerifyString(tesselation()) &&
           verifier.EndTable();
  }
};

struct ShaderProgramBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ShaderProgram::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ShaderProgram::VT_NAME, name);
  }
  void add_vertex(flatbuffers::Offset<flatbuffers::String> vertex) {
    fbb_.AddOffset(ShaderProgram::VT_VERTEX, vertex);
  }
  void add_fragment(flatbuffers::Offset<flatbuffers::String> fragment) {
    fbb_.AddOffset(ShaderProgram::VT_FRAGMENT, fragment);
  }
  void add_geometry(flatbuffers::Offset<flatbuffers::String> geometry) {
    fbb_.AddOffset(ShaderProgram::VT_GEOMETRY, geometry);
  }
  void add_tesselation(flatbuffers::Offset<flatbuffers::String> tesselation) {
    fbb_.AddOffset(ShaderProgram::VT_TESSELATION, tesselation);
  }
  explicit ShaderProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderProgramBuilder &operator=(const ShaderProgramBuilder &);
  flatbuffers::Offset<ShaderProgram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderProgram>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShaderProgram> CreateShaderProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> vertex = 0,
    flatbuffers::Offset<flatbuffers::String> fragment = 0,
    flatbuffers::Offset<flatbuffers::String> geometry = 0,
    flatbuffers::Offset<flatbuffers::String> tesselation = 0) {
  ShaderProgramBuilder builder_(_fbb);
  builder_.add_tesselation(tesselation);
  builder_.add_geometry(geometry);
  builder_.add_fragment(fragment);
  builder_.add_vertex(vertex);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderProgram> CreateShaderProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    const char *vertex = nullptr,
    const char *fragment = nullptr,
    const char *geometry = nullptr,
    const char *tesselation = nullptr) {
  return YASE::def::CreateShaderProgram(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      vertex ? _fbb.CreateString(vertex) : 0,
      fragment ? _fbb.CreateString(fragment) : 0,
      geometry ? _fbb.CreateString(geometry) : 0,
      tesselation ? _fbb.CreateString(tesselation) : 0);
}

struct SkyBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SkyBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SkyBox::VT_NAME, name);
  }
  explicit SkyBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkyBoxBuilder &operator=(const SkyBoxBuilder &);
  flatbuffers::Offset<SkyBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkyBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkyBox> CreateSkyBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SkyBoxBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkyBox> CreateSkyBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  return YASE::def::CreateSkyBox(
      _fbb,
      name ? _fbb.CreateString(name) : 0);
}

struct Texture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_CATEGORY = 6,
    VT_NAME = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12,
    VT_CHANNELS = 14
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *category() const {
    return GetPointer<const flatbuffers::String *>(VT_CATEGORY);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.VerifyString(category()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS) &&
           verifier.EndTable();
  }
};

struct TextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Texture::VT_ID, id, 0);
  }
  void add_category(flatbuffers::Offset<flatbuffers::String> category) {
    fbb_.AddOffset(Texture::VT_CATEGORY, category);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Texture::VT_NAME, name);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Texture::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Texture::VT_HEIGHT, height, 0);
  }
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(Texture::VT_CHANNELS, channels, 0);
  }
  explicit TextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureBuilder &operator=(const TextureBuilder &);
  flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Texture> CreateTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> category = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t width = 0,
    int32_t height = 0,
    int32_t channels = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_name(name);
  builder_.add_category(category);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Texture> CreateTextureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *category = nullptr,
    const char *name = nullptr,
    int32_t width = 0,
    int32_t height = 0,
    int32_t channels = 0) {
  return YASE::def::CreateTexture(
      _fbb,
      id,
      category ? _fbb.CreateString(category) : 0,
      name ? _fbb.CreateString(name) : 0,
      width,
      height,
      channels);
}

struct TextureSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WRAP = 4,
    VT_FILTER = 6
  };
  Wrapping wrap() const {
    return static_cast<Wrapping>(GetField<int8_t>(VT_WRAP, 0));
  }
  Filter filter() const {
    return static_cast<Filter>(GetField<int8_t>(VT_FILTER, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_WRAP) &&
           VerifyField<int8_t>(verifier, VT_FILTER) &&
           verifier.EndTable();
  }
};

struct TextureSettingsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wrap(Wrapping wrap) {
    fbb_.AddElement<int8_t>(TextureSettings::VT_WRAP, static_cast<int8_t>(wrap), 0);
  }
  void add_filter(Filter filter) {
    fbb_.AddElement<int8_t>(TextureSettings::VT_FILTER, static_cast<int8_t>(filter), 1);
  }
  explicit TextureSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureSettingsBuilder &operator=(const TextureSettingsBuilder &);
  flatbuffers::Offset<TextureSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureSettings> CreateTextureSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    Wrapping wrap = Wrapping_Repeat,
    Filter filter = Filter_Linear) {
  TextureSettingsBuilder builder_(_fbb);
  builder_.add_filter(filter);
  builder_.add_wrap(wrap);
  return builder_.Finish();
}

struct Ground FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TEXTURE_ID = 6,
    VT_SIZE = 8,
    VT_POS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t texture_id() const {
    return GetField<int32_t>(VT_TEXTURE_ID, 0);
  }
  const Vec3 *size() const {
    return GetStruct<const Vec3 *>(VT_SIZE);
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_TEXTURE_ID) &&
           VerifyField<Vec3>(verifier, VT_SIZE) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           verifier.EndTable();
  }
};

struct GroundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Ground::VT_NAME, name);
  }
  void add_texture_id(int32_t texture_id) {
    fbb_.AddElement<int32_t>(Ground::VT_TEXTURE_ID, texture_id, 0);
  }
  void add_size(const Vec3 *size) {
    fbb_.AddStruct(Ground::VT_SIZE, size);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(Ground::VT_POS, pos);
  }
  explicit GroundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroundBuilder &operator=(const GroundBuilder &);
  flatbuffers::Offset<Ground> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ground>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ground> CreateGround(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t texture_id = 0,
    const Vec3 *size = 0,
    const Vec3 *pos = 0) {
  GroundBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_size(size);
  builder_.add_texture_id(texture_id);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ground> CreateGroundDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t texture_id = 0,
    const Vec3 *size = 0,
    const Vec3 *pos = 0) {
  return YASE::def::CreateGround(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      texture_id,
      size,
      pos);
}

struct Environment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ROOT = 6,
    VT_CAMERA_DEFAULT = 8,
    VT_ACTIVE_SKYBOX = 10,
    VT_ACTIVE_GROUND = 12,
    VT_LIST_SKYBOX = 14,
    VT_LIST_SHADER = 16,
    VT_LIST_TEXTURES = 18,
    VT_LIST_GROUND = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *root() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOT);
  }
  const CameraPosition *camera_default() const {
    return GetStruct<const CameraPosition *>(VT_CAMERA_DEFAULT);
  }
  int32_t active_skybox() const {
    return GetField<int32_t>(VT_ACTIVE_SKYBOX, -1);
  }
  int32_t active_ground() const {
    return GetField<int32_t>(VT_ACTIVE_GROUND, -1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkyBox>> *list_skybox() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkyBox>> *>(VT_LIST_SKYBOX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShaderProgram>> *list_shader() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShaderProgram>> *>(VT_LIST_SHADER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Texture>> *list_textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Texture>> *>(VT_LIST_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ground>> *list_ground() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ground>> *>(VT_LIST_GROUND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ROOT) &&
           verifier.VerifyString(root()) &&
           VerifyField<CameraPosition>(verifier, VT_CAMERA_DEFAULT) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_SKYBOX) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_GROUND) &&
           VerifyOffset(verifier, VT_LIST_SKYBOX) &&
           verifier.VerifyVector(list_skybox()) &&
           verifier.VerifyVectorOfTables(list_skybox()) &&
           VerifyOffset(verifier, VT_LIST_SHADER) &&
           verifier.VerifyVector(list_shader()) &&
           verifier.VerifyVectorOfTables(list_shader()) &&
           VerifyOffset(verifier, VT_LIST_TEXTURES) &&
           verifier.VerifyVector(list_textures()) &&
           verifier.VerifyVectorOfTables(list_textures()) &&
           VerifyOffset(verifier, VT_LIST_GROUND) &&
           verifier.VerifyVector(list_ground()) &&
           verifier.VerifyVectorOfTables(list_ground()) &&
           verifier.EndTable();
  }
};

struct EnvironmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Environment::VT_NAME, name);
  }
  void add_root(flatbuffers::Offset<flatbuffers::String> root) {
    fbb_.AddOffset(Environment::VT_ROOT, root);
  }
  void add_camera_default(const CameraPosition *camera_default) {
    fbb_.AddStruct(Environment::VT_CAMERA_DEFAULT, camera_default);
  }
  void add_active_skybox(int32_t active_skybox) {
    fbb_.AddElement<int32_t>(Environment::VT_ACTIVE_SKYBOX, active_skybox, -1);
  }
  void add_active_ground(int32_t active_ground) {
    fbb_.AddElement<int32_t>(Environment::VT_ACTIVE_GROUND, active_ground, -1);
  }
  void add_list_skybox(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkyBox>>> list_skybox) {
    fbb_.AddOffset(Environment::VT_LIST_SKYBOX, list_skybox);
  }
  void add_list_shader(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderProgram>>> list_shader) {
    fbb_.AddOffset(Environment::VT_LIST_SHADER, list_shader);
  }
  void add_list_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> list_textures) {
    fbb_.AddOffset(Environment::VT_LIST_TEXTURES, list_textures);
  }
  void add_list_ground(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ground>>> list_ground) {
    fbb_.AddOffset(Environment::VT_LIST_GROUND, list_ground);
  }
  explicit EnvironmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnvironmentBuilder &operator=(const EnvironmentBuilder &);
  flatbuffers::Offset<Environment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Environment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Environment> CreateEnvironment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> root = 0,
    const CameraPosition *camera_default = 0,
    int32_t active_skybox = -1,
    int32_t active_ground = -1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkyBox>>> list_skybox = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderProgram>>> list_shader = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Texture>>> list_textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ground>>> list_ground = 0) {
  EnvironmentBuilder builder_(_fbb);
  builder_.add_list_ground(list_ground);
  builder_.add_list_textures(list_textures);
  builder_.add_list_shader(list_shader);
  builder_.add_list_skybox(list_skybox);
  builder_.add_active_ground(active_ground);
  builder_.add_active_skybox(active_skybox);
  builder_.add_camera_default(camera_default);
  builder_.add_root(root);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Environment> CreateEnvironmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *root = nullptr,
    const CameraPosition *camera_default = 0,
    int32_t active_skybox = -1,
    int32_t active_ground = -1,
    const std::vector<flatbuffers::Offset<SkyBox>> *list_skybox = nullptr,
    const std::vector<flatbuffers::Offset<ShaderProgram>> *list_shader = nullptr,
    const std::vector<flatbuffers::Offset<Texture>> *list_textures = nullptr,
    const std::vector<flatbuffers::Offset<Ground>> *list_ground = nullptr) {
  return YASE::def::CreateEnvironment(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      root ? _fbb.CreateString(root) : 0,
      camera_default,
      active_skybox,
      active_ground,
      list_skybox ? _fbb.CreateVector<flatbuffers::Offset<SkyBox>>(*list_skybox) : 0,
      list_shader ? _fbb.CreateVector<flatbuffers::Offset<ShaderProgram>>(*list_shader) : 0,
      list_textures ? _fbb.CreateVector<flatbuffers::Offset<Texture>>(*list_textures) : 0,
      list_ground ? _fbb.CreateVector<flatbuffers::Offset<Ground>>(*list_ground) : 0);
}

inline const YASE::def::Environment *GetEnvironment(const void *buf) {
  return flatbuffers::GetRoot<YASE::def::Environment>(buf);
}

inline const YASE::def::Environment *GetSizePrefixedEnvironment(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<YASE::def::Environment>(buf);
}

inline bool VerifyEnvironmentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<YASE::def::Environment>(nullptr);
}

inline bool VerifySizePrefixedEnvironmentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<YASE::def::Environment>(nullptr);
}

inline void FinishEnvironmentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<YASE::def::Environment> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvironmentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<YASE::def::Environment> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace def
}  // namespace YASE

#endif  // FLATBUFFERS_GENERATED_ENV_YASE_DEF_H_
